// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StorageNym.proto

#ifndef PROTOBUF_StorageNym_2eproto__INCLUDED
#define PROTOBUF_StorageNym_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "HDAccount.pb.h"  // IWYU pragma: export
#include "StorageBlockchainAccountList.pb.h"  // IWYU pragma: export
#include "StoragePurse.pb.h"  // IWYU pragma: export
#include "StorageItemHash.pb.h"  // IWYU pragma: export
// @@protoc_insertion_point(includes)

namespace protobuf_StorageNym_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsStorageNymImpl();
void InitDefaultsStorageNym();
inline void InitDefaults() {
  InitDefaultsStorageNym();
}
}  // namespace protobuf_StorageNym_2eproto
namespace opentxs {
namespace proto {
class StorageNym;
class StorageNymDefaultTypeInternal;
extern StorageNymDefaultTypeInternal _StorageNym_default_instance_;
}  // namespace proto
}  // namespace opentxs
namespace opentxs {
namespace proto {

// ===================================================================

class StorageNym : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:opentxs.proto.StorageNym) */ {
 public:
  StorageNym();
  virtual ~StorageNym();

  StorageNym(const StorageNym& from);

  inline StorageNym& operator=(const StorageNym& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StorageNym(StorageNym&& from) noexcept
    : StorageNym() {
    *this = ::std::move(from);
  }

  inline StorageNym& operator=(StorageNym&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StorageNym& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StorageNym* internal_default_instance() {
    return reinterpret_cast<const StorageNym*>(
               &_StorageNym_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(StorageNym* other);
  friend void swap(StorageNym& a, StorageNym& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StorageNym* New() const PROTOBUF_FINAL { return New(NULL); }

  StorageNym* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const StorageNym& from);
  void MergeFrom(const StorageNym& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StorageNym* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .opentxs.proto.StorageBlockchainAccountList BlockchainAccountIndex = 17;
  int blockchainaccountindex_size() const;
  void clear_blockchainaccountindex();
  static const int kBlockchainAccountIndexFieldNumber = 17;
  const ::opentxs::proto::StorageBlockchainAccountList& blockchainaccountindex(int index) const;
  ::opentxs::proto::StorageBlockchainAccountList* mutable_blockchainaccountindex(int index);
  ::opentxs::proto::StorageBlockchainAccountList* add_blockchainaccountindex();
  ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StorageBlockchainAccountList >*
      mutable_blockchainaccountindex();
  const ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StorageBlockchainAccountList >&
      blockchainaccountindex() const;

  // repeated .opentxs.proto.HDAccount HDAccount = 18;
  int hdaccount_size() const;
  void clear_hdaccount();
  static const int kHDAccountFieldNumber = 18;
  const ::opentxs::proto::HDAccount& hdaccount(int index) const;
  ::opentxs::proto::HDAccount* mutable_hdaccount(int index);
  ::opentxs::proto::HDAccount* add_hdaccount();
  ::google::protobuf::RepeatedPtrField< ::opentxs::proto::HDAccount >*
      mutable_hdaccount();
  const ::google::protobuf::RepeatedPtrField< ::opentxs::proto::HDAccount >&
      hdaccount() const;

  // repeated .opentxs.proto.StoragePurse purse = 22;
  int purse_size() const;
  void clear_purse();
  static const int kPurseFieldNumber = 22;
  const ::opentxs::proto::StoragePurse& purse(int index) const;
  ::opentxs::proto::StoragePurse* mutable_purse(int index);
  ::opentxs::proto::StoragePurse* add_purse();
  ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StoragePurse >*
      mutable_purse();
  const ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StoragePurse >&
      purse() const;

  // optional string nymid = 2;
  bool has_nymid() const;
  void clear_nymid();
  static const int kNymidFieldNumber = 2;
  const ::std::string& nymid() const;
  void set_nymid(const ::std::string& value);
  #if LANG_CXX11
  void set_nymid(::std::string&& value);
  #endif
  void set_nymid(const char* value);
  void set_nymid(const char* value, size_t size);
  ::std::string* mutable_nymid();
  ::std::string* release_nymid();
  void set_allocated_nymid(::std::string* nymid);

  // optional string issuers = 19;
  bool has_issuers() const;
  void clear_issuers();
  static const int kIssuersFieldNumber = 19;
  const ::std::string& issuers() const;
  void set_issuers(const ::std::string& value);
  #if LANG_CXX11
  void set_issuers(::std::string&& value);
  #endif
  void set_issuers(const char* value);
  void set_issuers(const char* value, size_t size);
  ::std::string* mutable_issuers();
  ::std::string* release_issuers();
  void set_allocated_issuers(::std::string* issuers);

  // optional string PaymentWorkflow = 20;
  bool has_paymentworkflow() const;
  void clear_paymentworkflow();
  static const int kPaymentWorkflowFieldNumber = 20;
  const ::std::string& paymentworkflow() const;
  void set_paymentworkflow(const ::std::string& value);
  #if LANG_CXX11
  void set_paymentworkflow(::std::string&& value);
  #endif
  void set_paymentworkflow(const char* value);
  void set_paymentworkflow(const char* value, size_t size);
  ::std::string* mutable_paymentworkflow();
  ::std::string* release_paymentworkflow();
  void set_allocated_paymentworkflow(::std::string* paymentworkflow);

  // optional string bip47 = 21;
  bool has_bip47() const;
  void clear_bip47();
  static const int kBip47FieldNumber = 21;
  const ::std::string& bip47() const;
  void set_bip47(const ::std::string& value);
  #if LANG_CXX11
  void set_bip47(::std::string&& value);
  #endif
  void set_bip47(const char* value);
  void set_bip47(const char* value, size_t size);
  ::std::string* mutable_bip47();
  ::std::string* release_bip47();
  void set_allocated_bip47(::std::string* bip47);

  // optional .opentxs.proto.StorageItemHash credList = 3;
  bool has_credlist() const;
  void clear_credlist();
  static const int kCredListFieldNumber = 3;
  const ::opentxs::proto::StorageItemHash& credlist() const;
  ::opentxs::proto::StorageItemHash* release_credlist();
  ::opentxs::proto::StorageItemHash* mutable_credlist();
  void set_allocated_credlist(::opentxs::proto::StorageItemHash* credlist);

  // optional .opentxs.proto.StorageItemHash SentPeerRequests = 4;
  bool has_sentpeerrequests() const;
  void clear_sentpeerrequests();
  static const int kSentPeerRequestsFieldNumber = 4;
  const ::opentxs::proto::StorageItemHash& sentpeerrequests() const;
  ::opentxs::proto::StorageItemHash* release_sentpeerrequests();
  ::opentxs::proto::StorageItemHash* mutable_sentpeerrequests();
  void set_allocated_sentpeerrequests(::opentxs::proto::StorageItemHash* sentpeerrequests);

  // optional .opentxs.proto.StorageItemHash IncomingPeerRequests = 5;
  bool has_incomingpeerrequests() const;
  void clear_incomingpeerrequests();
  static const int kIncomingPeerRequestsFieldNumber = 5;
  const ::opentxs::proto::StorageItemHash& incomingpeerrequests() const;
  ::opentxs::proto::StorageItemHash* release_incomingpeerrequests();
  ::opentxs::proto::StorageItemHash* mutable_incomingpeerrequests();
  void set_allocated_incomingpeerrequests(::opentxs::proto::StorageItemHash* incomingpeerrequests);

  // optional .opentxs.proto.StorageItemHash SentPeerReply = 6;
  bool has_sentpeerreply() const;
  void clear_sentpeerreply();
  static const int kSentPeerReplyFieldNumber = 6;
  const ::opentxs::proto::StorageItemHash& sentpeerreply() const;
  ::opentxs::proto::StorageItemHash* release_sentpeerreply();
  ::opentxs::proto::StorageItemHash* mutable_sentpeerreply();
  void set_allocated_sentpeerreply(::opentxs::proto::StorageItemHash* sentpeerreply);

  // optional .opentxs.proto.StorageItemHash IncomingPeerReply = 7;
  bool has_incomingpeerreply() const;
  void clear_incomingpeerreply();
  static const int kIncomingPeerReplyFieldNumber = 7;
  const ::opentxs::proto::StorageItemHash& incomingpeerreply() const;
  ::opentxs::proto::StorageItemHash* release_incomingpeerreply();
  ::opentxs::proto::StorageItemHash* mutable_incomingpeerreply();
  void set_allocated_incomingpeerreply(::opentxs::proto::StorageItemHash* incomingpeerreply);

  // optional .opentxs.proto.StorageItemHash FinishedPeerRequest = 8;
  bool has_finishedpeerrequest() const;
  void clear_finishedpeerrequest();
  static const int kFinishedPeerRequestFieldNumber = 8;
  const ::opentxs::proto::StorageItemHash& finishedpeerrequest() const;
  ::opentxs::proto::StorageItemHash* release_finishedpeerrequest();
  ::opentxs::proto::StorageItemHash* mutable_finishedpeerrequest();
  void set_allocated_finishedpeerrequest(::opentxs::proto::StorageItemHash* finishedpeerrequest);

  // optional .opentxs.proto.StorageItemHash FinishedPeerReply = 9;
  bool has_finishedpeerreply() const;
  void clear_finishedpeerreply();
  static const int kFinishedPeerReplyFieldNumber = 9;
  const ::opentxs::proto::StorageItemHash& finishedpeerreply() const;
  ::opentxs::proto::StorageItemHash* release_finishedpeerreply();
  ::opentxs::proto::StorageItemHash* mutable_finishedpeerreply();
  void set_allocated_finishedpeerreply(::opentxs::proto::StorageItemHash* finishedpeerreply);

  // optional .opentxs.proto.StorageItemHash ProcessedPeerRequest = 10;
  bool has_processedpeerrequest() const;
  void clear_processedpeerrequest();
  static const int kProcessedPeerRequestFieldNumber = 10;
  const ::opentxs::proto::StorageItemHash& processedpeerrequest() const;
  ::opentxs::proto::StorageItemHash* release_processedpeerrequest();
  ::opentxs::proto::StorageItemHash* mutable_processedpeerrequest();
  void set_allocated_processedpeerrequest(::opentxs::proto::StorageItemHash* processedpeerrequest);

  // optional .opentxs.proto.StorageItemHash ProcessedPeerReply = 11;
  bool has_processedpeerreply() const;
  void clear_processedpeerreply();
  static const int kProcessedPeerReplyFieldNumber = 11;
  const ::opentxs::proto::StorageItemHash& processedpeerreply() const;
  ::opentxs::proto::StorageItemHash* release_processedpeerreply();
  ::opentxs::proto::StorageItemHash* mutable_processedpeerreply();
  void set_allocated_processedpeerreply(::opentxs::proto::StorageItemHash* processedpeerreply);

  // optional .opentxs.proto.StorageItemHash MailInbox = 12;
  bool has_mailinbox() const;
  void clear_mailinbox();
  static const int kMailInboxFieldNumber = 12;
  const ::opentxs::proto::StorageItemHash& mailinbox() const;
  ::opentxs::proto::StorageItemHash* release_mailinbox();
  ::opentxs::proto::StorageItemHash* mutable_mailinbox();
  void set_allocated_mailinbox(::opentxs::proto::StorageItemHash* mailinbox);

  // optional .opentxs.proto.StorageItemHash MailOutbox = 13;
  bool has_mailoutbox() const;
  void clear_mailoutbox();
  static const int kMailOutboxFieldNumber = 13;
  const ::opentxs::proto::StorageItemHash& mailoutbox() const;
  ::opentxs::proto::StorageItemHash* release_mailoutbox();
  ::opentxs::proto::StorageItemHash* mutable_mailoutbox();
  void set_allocated_mailoutbox(::opentxs::proto::StorageItemHash* mailoutbox);

  // optional .opentxs.proto.StorageItemHash Threads = 14;
  bool has_threads() const;
  void clear_threads();
  static const int kThreadsFieldNumber = 14;
  const ::opentxs::proto::StorageItemHash& threads() const;
  ::opentxs::proto::StorageItemHash* release_threads();
  ::opentxs::proto::StorageItemHash* mutable_threads();
  void set_allocated_threads(::opentxs::proto::StorageItemHash* threads);

  // optional .opentxs.proto.StorageItemHash Contexts = 15;
  bool has_contexts() const;
  void clear_contexts();
  static const int kContextsFieldNumber = 15;
  const ::opentxs::proto::StorageItemHash& contexts() const;
  ::opentxs::proto::StorageItemHash* release_contexts();
  ::opentxs::proto::StorageItemHash* mutable_contexts();
  void set_allocated_contexts(::opentxs::proto::StorageItemHash* contexts);

  // optional .opentxs.proto.StorageItemHash Accounts = 16;
  bool has_accounts() const;
  void clear_accounts();
  static const int kAccountsFieldNumber = 16;
  const ::opentxs::proto::StorageItemHash& accounts() const;
  ::opentxs::proto::StorageItemHash* release_accounts();
  ::opentxs::proto::StorageItemHash* mutable_accounts();
  void set_allocated_accounts(::opentxs::proto::StorageItemHash* accounts);

  // optional .opentxs.proto.StorageItemHash txo = 23;
  bool has_txo() const;
  void clear_txo();
  static const int kTxoFieldNumber = 23;
  const ::opentxs::proto::StorageItemHash& txo() const;
  ::opentxs::proto::StorageItemHash* release_txo();
  ::opentxs::proto::StorageItemHash* mutable_txo();
  void set_allocated_txo(::opentxs::proto::StorageItemHash* txo);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:opentxs.proto.StorageNym)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_nymid();
  void clear_has_nymid();
  void set_has_credlist();
  void clear_has_credlist();
  void set_has_sentpeerrequests();
  void clear_has_sentpeerrequests();
  void set_has_incomingpeerrequests();
  void clear_has_incomingpeerrequests();
  void set_has_sentpeerreply();
  void clear_has_sentpeerreply();
  void set_has_incomingpeerreply();
  void clear_has_incomingpeerreply();
  void set_has_finishedpeerrequest();
  void clear_has_finishedpeerrequest();
  void set_has_finishedpeerreply();
  void clear_has_finishedpeerreply();
  void set_has_processedpeerrequest();
  void clear_has_processedpeerrequest();
  void set_has_processedpeerreply();
  void clear_has_processedpeerreply();
  void set_has_mailinbox();
  void clear_has_mailinbox();
  void set_has_mailoutbox();
  void clear_has_mailoutbox();
  void set_has_threads();
  void clear_has_threads();
  void set_has_contexts();
  void clear_has_contexts();
  void set_has_accounts();
  void clear_has_accounts();
  void set_has_issuers();
  void clear_has_issuers();
  void set_has_paymentworkflow();
  void clear_has_paymentworkflow();
  void set_has_bip47();
  void clear_has_bip47();
  void set_has_txo();
  void clear_has_txo();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StorageBlockchainAccountList > blockchainaccountindex_;
  ::google::protobuf::RepeatedPtrField< ::opentxs::proto::HDAccount > hdaccount_;
  ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StoragePurse > purse_;
  ::google::protobuf::internal::ArenaStringPtr nymid_;
  ::google::protobuf::internal::ArenaStringPtr issuers_;
  ::google::protobuf::internal::ArenaStringPtr paymentworkflow_;
  ::google::protobuf::internal::ArenaStringPtr bip47_;
  ::opentxs::proto::StorageItemHash* credlist_;
  ::opentxs::proto::StorageItemHash* sentpeerrequests_;
  ::opentxs::proto::StorageItemHash* incomingpeerrequests_;
  ::opentxs::proto::StorageItemHash* sentpeerreply_;
  ::opentxs::proto::StorageItemHash* incomingpeerreply_;
  ::opentxs::proto::StorageItemHash* finishedpeerrequest_;
  ::opentxs::proto::StorageItemHash* finishedpeerreply_;
  ::opentxs::proto::StorageItemHash* processedpeerrequest_;
  ::opentxs::proto::StorageItemHash* processedpeerreply_;
  ::opentxs::proto::StorageItemHash* mailinbox_;
  ::opentxs::proto::StorageItemHash* mailoutbox_;
  ::opentxs::proto::StorageItemHash* threads_;
  ::opentxs::proto::StorageItemHash* contexts_;
  ::opentxs::proto::StorageItemHash* accounts_;
  ::opentxs::proto::StorageItemHash* txo_;
  ::google::protobuf::uint32 version_;
  friend struct ::protobuf_StorageNym_2eproto::TableStruct;
  friend void ::protobuf_StorageNym_2eproto::InitDefaultsStorageNymImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StorageNym

// optional uint32 version = 1;
inline bool StorageNym::has_version() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void StorageNym::set_has_version() {
  _has_bits_[0] |= 0x00080000u;
}
inline void StorageNym::clear_has_version() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void StorageNym::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 StorageNym::version() const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.version)
  return version_;
}
inline void StorageNym::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:opentxs.proto.StorageNym.version)
}

// optional string nymid = 2;
inline bool StorageNym::has_nymid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageNym::set_has_nymid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageNym::clear_has_nymid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageNym::clear_nymid() {
  nymid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nymid();
}
inline const ::std::string& StorageNym::nymid() const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.nymid)
  return nymid_.GetNoArena();
}
inline void StorageNym::set_nymid(const ::std::string& value) {
  set_has_nymid();
  nymid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:opentxs.proto.StorageNym.nymid)
}
#if LANG_CXX11
inline void StorageNym::set_nymid(::std::string&& value) {
  set_has_nymid();
  nymid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:opentxs.proto.StorageNym.nymid)
}
#endif
inline void StorageNym::set_nymid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nymid();
  nymid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:opentxs.proto.StorageNym.nymid)
}
inline void StorageNym::set_nymid(const char* value, size_t size) {
  set_has_nymid();
  nymid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:opentxs.proto.StorageNym.nymid)
}
inline ::std::string* StorageNym::mutable_nymid() {
  set_has_nymid();
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.nymid)
  return nymid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageNym::release_nymid() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.nymid)
  clear_has_nymid();
  return nymid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageNym::set_allocated_nymid(::std::string* nymid) {
  if (nymid != NULL) {
    set_has_nymid();
  } else {
    clear_has_nymid();
  }
  nymid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nymid);
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.nymid)
}

// optional .opentxs.proto.StorageItemHash credList = 3;
inline bool StorageNym::has_credlist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StorageNym::set_has_credlist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StorageNym::clear_has_credlist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::credlist() const {
  const ::opentxs::proto::StorageItemHash* p = credlist_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.credList)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_credlist() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.credList)
  clear_has_credlist();
  ::opentxs::proto::StorageItemHash* temp = credlist_;
  credlist_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_credlist() {
  set_has_credlist();
  if (credlist_ == NULL) {
    credlist_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.credList)
  return credlist_;
}
inline void StorageNym::set_allocated_credlist(::opentxs::proto::StorageItemHash* credlist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(credlist_);
  }
  if (credlist) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      credlist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, credlist, submessage_arena);
    }
    set_has_credlist();
  } else {
    clear_has_credlist();
  }
  credlist_ = credlist;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.credList)
}

// optional .opentxs.proto.StorageItemHash SentPeerRequests = 4;
inline bool StorageNym::has_sentpeerrequests() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StorageNym::set_has_sentpeerrequests() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StorageNym::clear_has_sentpeerrequests() {
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::sentpeerrequests() const {
  const ::opentxs::proto::StorageItemHash* p = sentpeerrequests_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.SentPeerRequests)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_sentpeerrequests() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.SentPeerRequests)
  clear_has_sentpeerrequests();
  ::opentxs::proto::StorageItemHash* temp = sentpeerrequests_;
  sentpeerrequests_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_sentpeerrequests() {
  set_has_sentpeerrequests();
  if (sentpeerrequests_ == NULL) {
    sentpeerrequests_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.SentPeerRequests)
  return sentpeerrequests_;
}
inline void StorageNym::set_allocated_sentpeerrequests(::opentxs::proto::StorageItemHash* sentpeerrequests) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sentpeerrequests_);
  }
  if (sentpeerrequests) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sentpeerrequests = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sentpeerrequests, submessage_arena);
    }
    set_has_sentpeerrequests();
  } else {
    clear_has_sentpeerrequests();
  }
  sentpeerrequests_ = sentpeerrequests;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.SentPeerRequests)
}

// optional .opentxs.proto.StorageItemHash IncomingPeerRequests = 5;
inline bool StorageNym::has_incomingpeerrequests() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StorageNym::set_has_incomingpeerrequests() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StorageNym::clear_has_incomingpeerrequests() {
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::incomingpeerrequests() const {
  const ::opentxs::proto::StorageItemHash* p = incomingpeerrequests_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.IncomingPeerRequests)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_incomingpeerrequests() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.IncomingPeerRequests)
  clear_has_incomingpeerrequests();
  ::opentxs::proto::StorageItemHash* temp = incomingpeerrequests_;
  incomingpeerrequests_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_incomingpeerrequests() {
  set_has_incomingpeerrequests();
  if (incomingpeerrequests_ == NULL) {
    incomingpeerrequests_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.IncomingPeerRequests)
  return incomingpeerrequests_;
}
inline void StorageNym::set_allocated_incomingpeerrequests(::opentxs::proto::StorageItemHash* incomingpeerrequests) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(incomingpeerrequests_);
  }
  if (incomingpeerrequests) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      incomingpeerrequests = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, incomingpeerrequests, submessage_arena);
    }
    set_has_incomingpeerrequests();
  } else {
    clear_has_incomingpeerrequests();
  }
  incomingpeerrequests_ = incomingpeerrequests;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.IncomingPeerRequests)
}

// optional .opentxs.proto.StorageItemHash SentPeerReply = 6;
inline bool StorageNym::has_sentpeerreply() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StorageNym::set_has_sentpeerreply() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StorageNym::clear_has_sentpeerreply() {
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::sentpeerreply() const {
  const ::opentxs::proto::StorageItemHash* p = sentpeerreply_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.SentPeerReply)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_sentpeerreply() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.SentPeerReply)
  clear_has_sentpeerreply();
  ::opentxs::proto::StorageItemHash* temp = sentpeerreply_;
  sentpeerreply_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_sentpeerreply() {
  set_has_sentpeerreply();
  if (sentpeerreply_ == NULL) {
    sentpeerreply_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.SentPeerReply)
  return sentpeerreply_;
}
inline void StorageNym::set_allocated_sentpeerreply(::opentxs::proto::StorageItemHash* sentpeerreply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(sentpeerreply_);
  }
  if (sentpeerreply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sentpeerreply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sentpeerreply, submessage_arena);
    }
    set_has_sentpeerreply();
  } else {
    clear_has_sentpeerreply();
  }
  sentpeerreply_ = sentpeerreply;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.SentPeerReply)
}

// optional .opentxs.proto.StorageItemHash IncomingPeerReply = 7;
inline bool StorageNym::has_incomingpeerreply() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StorageNym::set_has_incomingpeerreply() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StorageNym::clear_has_incomingpeerreply() {
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::incomingpeerreply() const {
  const ::opentxs::proto::StorageItemHash* p = incomingpeerreply_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.IncomingPeerReply)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_incomingpeerreply() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.IncomingPeerReply)
  clear_has_incomingpeerreply();
  ::opentxs::proto::StorageItemHash* temp = incomingpeerreply_;
  incomingpeerreply_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_incomingpeerreply() {
  set_has_incomingpeerreply();
  if (incomingpeerreply_ == NULL) {
    incomingpeerreply_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.IncomingPeerReply)
  return incomingpeerreply_;
}
inline void StorageNym::set_allocated_incomingpeerreply(::opentxs::proto::StorageItemHash* incomingpeerreply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(incomingpeerreply_);
  }
  if (incomingpeerreply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      incomingpeerreply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, incomingpeerreply, submessage_arena);
    }
    set_has_incomingpeerreply();
  } else {
    clear_has_incomingpeerreply();
  }
  incomingpeerreply_ = incomingpeerreply;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.IncomingPeerReply)
}

// optional .opentxs.proto.StorageItemHash FinishedPeerRequest = 8;
inline bool StorageNym::has_finishedpeerrequest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StorageNym::set_has_finishedpeerrequest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StorageNym::clear_has_finishedpeerrequest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::finishedpeerrequest() const {
  const ::opentxs::proto::StorageItemHash* p = finishedpeerrequest_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.FinishedPeerRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_finishedpeerrequest() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.FinishedPeerRequest)
  clear_has_finishedpeerrequest();
  ::opentxs::proto::StorageItemHash* temp = finishedpeerrequest_;
  finishedpeerrequest_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_finishedpeerrequest() {
  set_has_finishedpeerrequest();
  if (finishedpeerrequest_ == NULL) {
    finishedpeerrequest_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.FinishedPeerRequest)
  return finishedpeerrequest_;
}
inline void StorageNym::set_allocated_finishedpeerrequest(::opentxs::proto::StorageItemHash* finishedpeerrequest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(finishedpeerrequest_);
  }
  if (finishedpeerrequest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      finishedpeerrequest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, finishedpeerrequest, submessage_arena);
    }
    set_has_finishedpeerrequest();
  } else {
    clear_has_finishedpeerrequest();
  }
  finishedpeerrequest_ = finishedpeerrequest;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.FinishedPeerRequest)
}

// optional .opentxs.proto.StorageItemHash FinishedPeerReply = 9;
inline bool StorageNym::has_finishedpeerreply() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StorageNym::set_has_finishedpeerreply() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StorageNym::clear_has_finishedpeerreply() {
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::finishedpeerreply() const {
  const ::opentxs::proto::StorageItemHash* p = finishedpeerreply_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.FinishedPeerReply)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_finishedpeerreply() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.FinishedPeerReply)
  clear_has_finishedpeerreply();
  ::opentxs::proto::StorageItemHash* temp = finishedpeerreply_;
  finishedpeerreply_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_finishedpeerreply() {
  set_has_finishedpeerreply();
  if (finishedpeerreply_ == NULL) {
    finishedpeerreply_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.FinishedPeerReply)
  return finishedpeerreply_;
}
inline void StorageNym::set_allocated_finishedpeerreply(::opentxs::proto::StorageItemHash* finishedpeerreply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(finishedpeerreply_);
  }
  if (finishedpeerreply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      finishedpeerreply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, finishedpeerreply, submessage_arena);
    }
    set_has_finishedpeerreply();
  } else {
    clear_has_finishedpeerreply();
  }
  finishedpeerreply_ = finishedpeerreply;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.FinishedPeerReply)
}

// optional .opentxs.proto.StorageItemHash ProcessedPeerRequest = 10;
inline bool StorageNym::has_processedpeerrequest() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StorageNym::set_has_processedpeerrequest() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StorageNym::clear_has_processedpeerrequest() {
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::processedpeerrequest() const {
  const ::opentxs::proto::StorageItemHash* p = processedpeerrequest_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.ProcessedPeerRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_processedpeerrequest() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.ProcessedPeerRequest)
  clear_has_processedpeerrequest();
  ::opentxs::proto::StorageItemHash* temp = processedpeerrequest_;
  processedpeerrequest_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_processedpeerrequest() {
  set_has_processedpeerrequest();
  if (processedpeerrequest_ == NULL) {
    processedpeerrequest_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.ProcessedPeerRequest)
  return processedpeerrequest_;
}
inline void StorageNym::set_allocated_processedpeerrequest(::opentxs::proto::StorageItemHash* processedpeerrequest) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(processedpeerrequest_);
  }
  if (processedpeerrequest) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      processedpeerrequest = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, processedpeerrequest, submessage_arena);
    }
    set_has_processedpeerrequest();
  } else {
    clear_has_processedpeerrequest();
  }
  processedpeerrequest_ = processedpeerrequest;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.ProcessedPeerRequest)
}

// optional .opentxs.proto.StorageItemHash ProcessedPeerReply = 11;
inline bool StorageNym::has_processedpeerreply() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StorageNym::set_has_processedpeerreply() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StorageNym::clear_has_processedpeerreply() {
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::processedpeerreply() const {
  const ::opentxs::proto::StorageItemHash* p = processedpeerreply_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.ProcessedPeerReply)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_processedpeerreply() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.ProcessedPeerReply)
  clear_has_processedpeerreply();
  ::opentxs::proto::StorageItemHash* temp = processedpeerreply_;
  processedpeerreply_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_processedpeerreply() {
  set_has_processedpeerreply();
  if (processedpeerreply_ == NULL) {
    processedpeerreply_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.ProcessedPeerReply)
  return processedpeerreply_;
}
inline void StorageNym::set_allocated_processedpeerreply(::opentxs::proto::StorageItemHash* processedpeerreply) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(processedpeerreply_);
  }
  if (processedpeerreply) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      processedpeerreply = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, processedpeerreply, submessage_arena);
    }
    set_has_processedpeerreply();
  } else {
    clear_has_processedpeerreply();
  }
  processedpeerreply_ = processedpeerreply;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.ProcessedPeerReply)
}

// optional .opentxs.proto.StorageItemHash MailInbox = 12;
inline bool StorageNym::has_mailinbox() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void StorageNym::set_has_mailinbox() {
  _has_bits_[0] |= 0x00002000u;
}
inline void StorageNym::clear_has_mailinbox() {
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::mailinbox() const {
  const ::opentxs::proto::StorageItemHash* p = mailinbox_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.MailInbox)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_mailinbox() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.MailInbox)
  clear_has_mailinbox();
  ::opentxs::proto::StorageItemHash* temp = mailinbox_;
  mailinbox_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_mailinbox() {
  set_has_mailinbox();
  if (mailinbox_ == NULL) {
    mailinbox_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.MailInbox)
  return mailinbox_;
}
inline void StorageNym::set_allocated_mailinbox(::opentxs::proto::StorageItemHash* mailinbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mailinbox_);
  }
  if (mailinbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mailinbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mailinbox, submessage_arena);
    }
    set_has_mailinbox();
  } else {
    clear_has_mailinbox();
  }
  mailinbox_ = mailinbox;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.MailInbox)
}

// optional .opentxs.proto.StorageItemHash MailOutbox = 13;
inline bool StorageNym::has_mailoutbox() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void StorageNym::set_has_mailoutbox() {
  _has_bits_[0] |= 0x00004000u;
}
inline void StorageNym::clear_has_mailoutbox() {
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::mailoutbox() const {
  const ::opentxs::proto::StorageItemHash* p = mailoutbox_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.MailOutbox)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_mailoutbox() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.MailOutbox)
  clear_has_mailoutbox();
  ::opentxs::proto::StorageItemHash* temp = mailoutbox_;
  mailoutbox_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_mailoutbox() {
  set_has_mailoutbox();
  if (mailoutbox_ == NULL) {
    mailoutbox_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.MailOutbox)
  return mailoutbox_;
}
inline void StorageNym::set_allocated_mailoutbox(::opentxs::proto::StorageItemHash* mailoutbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(mailoutbox_);
  }
  if (mailoutbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mailoutbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mailoutbox, submessage_arena);
    }
    set_has_mailoutbox();
  } else {
    clear_has_mailoutbox();
  }
  mailoutbox_ = mailoutbox;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.MailOutbox)
}

// optional .opentxs.proto.StorageItemHash Threads = 14;
inline bool StorageNym::has_threads() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void StorageNym::set_has_threads() {
  _has_bits_[0] |= 0x00008000u;
}
inline void StorageNym::clear_has_threads() {
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::threads() const {
  const ::opentxs::proto::StorageItemHash* p = threads_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.Threads)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_threads() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.Threads)
  clear_has_threads();
  ::opentxs::proto::StorageItemHash* temp = threads_;
  threads_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_threads() {
  set_has_threads();
  if (threads_ == NULL) {
    threads_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.Threads)
  return threads_;
}
inline void StorageNym::set_allocated_threads(::opentxs::proto::StorageItemHash* threads) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(threads_);
  }
  if (threads) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      threads = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, threads, submessage_arena);
    }
    set_has_threads();
  } else {
    clear_has_threads();
  }
  threads_ = threads;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.Threads)
}

// optional .opentxs.proto.StorageItemHash Contexts = 15;
inline bool StorageNym::has_contexts() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void StorageNym::set_has_contexts() {
  _has_bits_[0] |= 0x00010000u;
}
inline void StorageNym::clear_has_contexts() {
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::contexts() const {
  const ::opentxs::proto::StorageItemHash* p = contexts_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.Contexts)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_contexts() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.Contexts)
  clear_has_contexts();
  ::opentxs::proto::StorageItemHash* temp = contexts_;
  contexts_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_contexts() {
  set_has_contexts();
  if (contexts_ == NULL) {
    contexts_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.Contexts)
  return contexts_;
}
inline void StorageNym::set_allocated_contexts(::opentxs::proto::StorageItemHash* contexts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(contexts_);
  }
  if (contexts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contexts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contexts, submessage_arena);
    }
    set_has_contexts();
  } else {
    clear_has_contexts();
  }
  contexts_ = contexts;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.Contexts)
}

// optional .opentxs.proto.StorageItemHash Accounts = 16;
inline bool StorageNym::has_accounts() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void StorageNym::set_has_accounts() {
  _has_bits_[0] |= 0x00020000u;
}
inline void StorageNym::clear_has_accounts() {
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::accounts() const {
  const ::opentxs::proto::StorageItemHash* p = accounts_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.Accounts)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_accounts() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.Accounts)
  clear_has_accounts();
  ::opentxs::proto::StorageItemHash* temp = accounts_;
  accounts_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_accounts() {
  set_has_accounts();
  if (accounts_ == NULL) {
    accounts_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.Accounts)
  return accounts_;
}
inline void StorageNym::set_allocated_accounts(::opentxs::proto::StorageItemHash* accounts) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(accounts_);
  }
  if (accounts) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      accounts = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accounts, submessage_arena);
    }
    set_has_accounts();
  } else {
    clear_has_accounts();
  }
  accounts_ = accounts;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.Accounts)
}

// repeated .opentxs.proto.StorageBlockchainAccountList BlockchainAccountIndex = 17;
inline int StorageNym::blockchainaccountindex_size() const {
  return blockchainaccountindex_.size();
}
inline const ::opentxs::proto::StorageBlockchainAccountList& StorageNym::blockchainaccountindex(int index) const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.BlockchainAccountIndex)
  return blockchainaccountindex_.Get(index);
}
inline ::opentxs::proto::StorageBlockchainAccountList* StorageNym::mutable_blockchainaccountindex(int index) {
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.BlockchainAccountIndex)
  return blockchainaccountindex_.Mutable(index);
}
inline ::opentxs::proto::StorageBlockchainAccountList* StorageNym::add_blockchainaccountindex() {
  // @@protoc_insertion_point(field_add:opentxs.proto.StorageNym.BlockchainAccountIndex)
  return blockchainaccountindex_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StorageBlockchainAccountList >*
StorageNym::mutable_blockchainaccountindex() {
  // @@protoc_insertion_point(field_mutable_list:opentxs.proto.StorageNym.BlockchainAccountIndex)
  return &blockchainaccountindex_;
}
inline const ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StorageBlockchainAccountList >&
StorageNym::blockchainaccountindex() const {
  // @@protoc_insertion_point(field_list:opentxs.proto.StorageNym.BlockchainAccountIndex)
  return blockchainaccountindex_;
}

// repeated .opentxs.proto.HDAccount HDAccount = 18;
inline int StorageNym::hdaccount_size() const {
  return hdaccount_.size();
}
inline const ::opentxs::proto::HDAccount& StorageNym::hdaccount(int index) const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.HDAccount)
  return hdaccount_.Get(index);
}
inline ::opentxs::proto::HDAccount* StorageNym::mutable_hdaccount(int index) {
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.HDAccount)
  return hdaccount_.Mutable(index);
}
inline ::opentxs::proto::HDAccount* StorageNym::add_hdaccount() {
  // @@protoc_insertion_point(field_add:opentxs.proto.StorageNym.HDAccount)
  return hdaccount_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::opentxs::proto::HDAccount >*
StorageNym::mutable_hdaccount() {
  // @@protoc_insertion_point(field_mutable_list:opentxs.proto.StorageNym.HDAccount)
  return &hdaccount_;
}
inline const ::google::protobuf::RepeatedPtrField< ::opentxs::proto::HDAccount >&
StorageNym::hdaccount() const {
  // @@protoc_insertion_point(field_list:opentxs.proto.StorageNym.HDAccount)
  return hdaccount_;
}

// optional string issuers = 19;
inline bool StorageNym::has_issuers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageNym::set_has_issuers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageNym::clear_has_issuers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageNym::clear_issuers() {
  issuers_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_issuers();
}
inline const ::std::string& StorageNym::issuers() const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.issuers)
  return issuers_.GetNoArena();
}
inline void StorageNym::set_issuers(const ::std::string& value) {
  set_has_issuers();
  issuers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:opentxs.proto.StorageNym.issuers)
}
#if LANG_CXX11
inline void StorageNym::set_issuers(::std::string&& value) {
  set_has_issuers();
  issuers_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:opentxs.proto.StorageNym.issuers)
}
#endif
inline void StorageNym::set_issuers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_issuers();
  issuers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:opentxs.proto.StorageNym.issuers)
}
inline void StorageNym::set_issuers(const char* value, size_t size) {
  set_has_issuers();
  issuers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:opentxs.proto.StorageNym.issuers)
}
inline ::std::string* StorageNym::mutable_issuers() {
  set_has_issuers();
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.issuers)
  return issuers_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageNym::release_issuers() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.issuers)
  clear_has_issuers();
  return issuers_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageNym::set_allocated_issuers(::std::string* issuers) {
  if (issuers != NULL) {
    set_has_issuers();
  } else {
    clear_has_issuers();
  }
  issuers_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), issuers);
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.issuers)
}

// optional string PaymentWorkflow = 20;
inline bool StorageNym::has_paymentworkflow() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageNym::set_has_paymentworkflow() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StorageNym::clear_has_paymentworkflow() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StorageNym::clear_paymentworkflow() {
  paymentworkflow_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_paymentworkflow();
}
inline const ::std::string& StorageNym::paymentworkflow() const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.PaymentWorkflow)
  return paymentworkflow_.GetNoArena();
}
inline void StorageNym::set_paymentworkflow(const ::std::string& value) {
  set_has_paymentworkflow();
  paymentworkflow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:opentxs.proto.StorageNym.PaymentWorkflow)
}
#if LANG_CXX11
inline void StorageNym::set_paymentworkflow(::std::string&& value) {
  set_has_paymentworkflow();
  paymentworkflow_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:opentxs.proto.StorageNym.PaymentWorkflow)
}
#endif
inline void StorageNym::set_paymentworkflow(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_paymentworkflow();
  paymentworkflow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:opentxs.proto.StorageNym.PaymentWorkflow)
}
inline void StorageNym::set_paymentworkflow(const char* value, size_t size) {
  set_has_paymentworkflow();
  paymentworkflow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:opentxs.proto.StorageNym.PaymentWorkflow)
}
inline ::std::string* StorageNym::mutable_paymentworkflow() {
  set_has_paymentworkflow();
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.PaymentWorkflow)
  return paymentworkflow_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageNym::release_paymentworkflow() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.PaymentWorkflow)
  clear_has_paymentworkflow();
  return paymentworkflow_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageNym::set_allocated_paymentworkflow(::std::string* paymentworkflow) {
  if (paymentworkflow != NULL) {
    set_has_paymentworkflow();
  } else {
    clear_has_paymentworkflow();
  }
  paymentworkflow_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), paymentworkflow);
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.PaymentWorkflow)
}

// optional string bip47 = 21;
inline bool StorageNym::has_bip47() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StorageNym::set_has_bip47() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StorageNym::clear_has_bip47() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StorageNym::clear_bip47() {
  bip47_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bip47();
}
inline const ::std::string& StorageNym::bip47() const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.bip47)
  return bip47_.GetNoArena();
}
inline void StorageNym::set_bip47(const ::std::string& value) {
  set_has_bip47();
  bip47_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:opentxs.proto.StorageNym.bip47)
}
#if LANG_CXX11
inline void StorageNym::set_bip47(::std::string&& value) {
  set_has_bip47();
  bip47_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:opentxs.proto.StorageNym.bip47)
}
#endif
inline void StorageNym::set_bip47(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bip47();
  bip47_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:opentxs.proto.StorageNym.bip47)
}
inline void StorageNym::set_bip47(const char* value, size_t size) {
  set_has_bip47();
  bip47_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:opentxs.proto.StorageNym.bip47)
}
inline ::std::string* StorageNym::mutable_bip47() {
  set_has_bip47();
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.bip47)
  return bip47_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StorageNym::release_bip47() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.bip47)
  clear_has_bip47();
  return bip47_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StorageNym::set_allocated_bip47(::std::string* bip47) {
  if (bip47 != NULL) {
    set_has_bip47();
  } else {
    clear_has_bip47();
  }
  bip47_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bip47);
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.bip47)
}

// repeated .opentxs.proto.StoragePurse purse = 22;
inline int StorageNym::purse_size() const {
  return purse_.size();
}
inline const ::opentxs::proto::StoragePurse& StorageNym::purse(int index) const {
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.purse)
  return purse_.Get(index);
}
inline ::opentxs::proto::StoragePurse* StorageNym::mutable_purse(int index) {
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.purse)
  return purse_.Mutable(index);
}
inline ::opentxs::proto::StoragePurse* StorageNym::add_purse() {
  // @@protoc_insertion_point(field_add:opentxs.proto.StorageNym.purse)
  return purse_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StoragePurse >*
StorageNym::mutable_purse() {
  // @@protoc_insertion_point(field_mutable_list:opentxs.proto.StorageNym.purse)
  return &purse_;
}
inline const ::google::protobuf::RepeatedPtrField< ::opentxs::proto::StoragePurse >&
StorageNym::purse() const {
  // @@protoc_insertion_point(field_list:opentxs.proto.StorageNym.purse)
  return purse_;
}

// optional .opentxs.proto.StorageItemHash txo = 23;
inline bool StorageNym::has_txo() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void StorageNym::set_has_txo() {
  _has_bits_[0] |= 0x00040000u;
}
inline void StorageNym::clear_has_txo() {
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::opentxs::proto::StorageItemHash& StorageNym::txo() const {
  const ::opentxs::proto::StorageItemHash* p = txo_;
  // @@protoc_insertion_point(field_get:opentxs.proto.StorageNym.txo)
  return p != NULL ? *p : *reinterpret_cast<const ::opentxs::proto::StorageItemHash*>(
      &::opentxs::proto::_StorageItemHash_default_instance_);
}
inline ::opentxs::proto::StorageItemHash* StorageNym::release_txo() {
  // @@protoc_insertion_point(field_release:opentxs.proto.StorageNym.txo)
  clear_has_txo();
  ::opentxs::proto::StorageItemHash* temp = txo_;
  txo_ = NULL;
  return temp;
}
inline ::opentxs::proto::StorageItemHash* StorageNym::mutable_txo() {
  set_has_txo();
  if (txo_ == NULL) {
    txo_ = new ::opentxs::proto::StorageItemHash;
  }
  // @@protoc_insertion_point(field_mutable:opentxs.proto.StorageNym.txo)
  return txo_;
}
inline void StorageNym::set_allocated_txo(::opentxs::proto::StorageItemHash* txo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(txo_);
  }
  if (txo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      txo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, txo, submessage_arena);
    }
    set_has_txo();
  } else {
    clear_has_txo();
  }
  txo_ = txo;
  // @@protoc_insertion_point(field_set_allocated:opentxs.proto.StorageNym.txo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace opentxs

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StorageNym_2eproto__INCLUDED
